import argparse
import os
import numpy as np
import pandas as pd
from scipy import sparse
import pickle
import glob

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("src_dir", help="Directory of source raw data, downloaded by `bash get_data.sh`.", type=str)
    parser.add_argument("enc_dir", help="Directory of source raw data, generated by `bash encode.sh`.", type=str)
    parser.add_argument("tgt_dir", help="Directory of to save processed PECOS format data.", type=str)
    parser.add_argument('--intersect_pos_neg', action='store_true')
    parser.add_argument('--XZ_only', action='store_true')
    return parser.parse_args()

def main():
    args = parse_args()

    save_dir = os.path.join(args.tgt_dir)
    os.makedirs(save_dir, exist_ok=True)

    nx_trn = 502939 
    nx_tst = 6980 
    nz = 8841823 

    # X
    with open(os.path.join(args.enc_dir, 'query', 'qry.trn.pt'), 'rb') as f:
        X_embs, indices = pickle.load(f)
        X_embs = np.array(X_embs)
        indices = np.array(indices).astype(int)
    X_i2i_trn = {ii: i for i, ii in enumerate(indices)}
    print(X_embs.shape, indices.shape, X_embs.min(), X_embs.max(), indices.min(), indices.max())
    if not os.path.exists(os.path.join(save_dir, f'X.trn.npz')):
        np.savez(os.path.join(save_dir, f'X.trn.npz'), embs=X_embs, indices=indices)

    with open(os.path.join(args.enc_dir, 'query', 'qry.dev.pt'), 'rb') as f:
        X_embs, indices = pickle.load(f)
        X_embs = np.array(X_embs)
        indices = np.array(indices).astype(int)
    X_i2i_tst = {ii: i for i, ii in enumerate(indices)}
    print(X_embs.shape, indices.shape, X_embs.min(), X_embs.max(), indices.min(), indices.max())
    if not os.path.exists(os.path.join(save_dir, f'X.tst.npz')):
        np.savez(os.path.join(save_dir, f'X.tst.npz'), embs=X_embs, indices=indices)

    # Z
    Z_embs, indices = [], []
    for pkl_path in sorted(glob.glob(os.path.join(args.enc_dir, 'corpus', 'split*.pt'))):
        with open(pkl_path, 'rb') as f:
            embs_, indices_ = pickle.load(f)
            embs_ = np.array(embs_)
            indices_ = np.array(indices_).astype(int)
            print(embs_.shape, indices_.shape, pkl_path, embs_.min(), embs_.max(), indices_.min(), indices_.max())

            Z_embs.append(embs_)
            indices.append(indices_)

    Z_embs = np.concatenate(Z_embs, axis=0)
    indices = np.concatenate(indices, axis=0)
    print(Z_embs.shape)

    if not os.path.exists(os.path.join(save_dir, 'Z.npz')):
        np.savez(os.path.join(save_dir, 'Z.npz'), embs=Z_embs, indices=indices)
        
    if args.XZ_only:
        return

    # Y
    pos_trn_lbl_path = os.path.join(args.src_dir, "qrels.train.tsv")
    neg_trn_lbl_path = os.path.join(args.src_dir, "train.negatives.tsv")
    pos_tst_lbl_path = os.path.join(args.src_dir, "qrels.dev.tsv")

    pos_trn_lbl = pd.read_csv(pos_trn_lbl_path, sep='\t')
    pos_tst_lbl = pd.read_csv(pos_tst_lbl_path, sep='\t')
    print(pos_trn_lbl.iloc[:, 0].min(), pos_trn_lbl.iloc[:, 0].max(), pos_trn_lbl.iloc[:, 2].min(), pos_trn_lbl.iloc[:, 2].max())
    print(pos_tst_lbl.iloc[:, 0].min(), pos_tst_lbl.iloc[:, 0].max(), pos_tst_lbl.iloc[:, 1].min(), pos_tst_lbl.iloc[:, 1].max())

    # ((data, (row_ind, col_ind)), [shape=(M, N)])
    Y_row_pos_trn = pos_trn_lbl.iloc[:, 0].apply(lambda x: X_i2i_trn[int(x)])
    Y_col_pos_trn = pos_trn_lbl.iloc[:, 2]
    
    Y_row_pos_tst = pos_tst_lbl.iloc[:, 0].apply(lambda x: X_i2i_tst[int(x)])
    Y_col_pos_tst = pos_tst_lbl.iloc[:, 1]
    
    Y_row_neg_trn, Y_col_neg_trn = [], []
    with open(neg_trn_lbl_path, 'r') as f:
        for l in f.read().splitlines():
            r, cs = l.split('\t')
            cs = cs.split(',')
            r = X_i2i_trn[int(r)]
            rs = [r] * len(cs)
            Y_row_neg_trn += rs
            Y_col_neg_trn += cs
    Y_row_neg_trn, Y_col_neg_trn = np.array(Y_row_neg_trn), np.array(Y_col_neg_trn)
    
    if args.intersect_pos_neg:
        urow_pos_trn = np.unique(Y_row_pos_trn)
        urow_neg_trn = np.unique(Y_row_neg_trn)
        urow_trn = np.intersect1d(urow_pos_trn, urow_neg_trn)
        
        print(f"# of unique rows after intersection = {len(urow_trn)}")
        
        mask_pos = np.isin(Y_row_pos_trn, urow_trn)
        mask_neg = np.isin(Y_row_neg_trn, urow_trn)
        
        Y_row_pos_trn = Y_row_pos_trn[mask_pos]
        Y_col_pos_trn = Y_col_pos_trn[mask_pos]
        
        Y_row_neg_trn = Y_row_neg_trn[mask_neg]
        Y_col_neg_trn = Y_col_neg_trn[mask_neg]
    
    Y_pos_trn = sparse.csr_matrix((np.ones(len(Y_row_pos_trn)), (Y_row_pos_trn, Y_col_pos_trn)), (nx_trn, nz))
    Y_pos_trn.data = np.ones_like(Y_pos_trn.data) # process dulicates
    
    Y_neg_trn = sparse.csr_matrix((-1 * np.ones(len(Y_col_neg_trn)), (Y_row_neg_trn, Y_col_neg_trn)), (nx_trn, nz))
    Y_neg_trn.data = -1 * np.ones_like(Y_neg_trn.data) # process dulicates
    
    Y_pos_tst = sparse.csr_matrix((np.ones(len(Y_row_pos_tst)), (Y_row_pos_tst, Y_col_pos_tst)), (nx_tst, nz))
    Y_pos_tst.data = np.ones_like(Y_pos_tst.data) # process dulicates
    
    print(f"Y_pos_trn.nnz = {Y_pos_trn.nnz}")
    print(f"Y_neg_trn.nnz = {Y_neg_trn.nnz}")
    print(f"Y_pos_tst.nnz = {Y_pos_tst.nnz}")
    
    Y_trn = Y_pos_trn + Y_neg_trn
    
    assert set(Y_trn.data) == set([-1, 1])
    assert set(Y_pos_tst.data) == set([1])

    sparse.save_npz(os.path.join(save_dir, 'Y.trn.pos.npz'), Y_pos_trn, compressed=False)
    sparse.save_npz(os.path.join(save_dir, 'Y.trn.npz'), Y_trn, compressed=False)
    sparse.save_npz(os.path.join(save_dir, 'Y.tst.pos.npz'), Y_pos_tst, compressed=False)
    os.symlink(os.path.abspath(os.path.join(save_dir, 'Y.tst.pos.npz')), os.path.join(save_dir, 'Y.tst.npz'))

if __name__ == '__main__':
    main()
